# 加密和混淆管线

魔曰使用 AES-256-CTR 作为核心加密算法。使得密文的安全性有强力保证。

## AES-256

魔曰会将用户提供的密钥，执行一次 SHA256 哈希，取其值作为密钥。

然后，对第一次哈希的结果附加两个随机字节，再次哈希，取其值作为加密的 IV。

## 高级加密

魔曰支持数个高级加密套件，允许资深用户增强密文的安全性。

除 AES-256-CTR 外，下列密码套件受支持：

- **StrongIV**
- **HMAC-SHA256**
- **PBKDF2**
- **TOTP**

启用高级加密套件将导致密文长度显著增加，所有组件均可独立开启和关闭。

### StrongIV

为了节省密文长度，魔曰默认使用熵为 16bits 的 2 字节初始化向量(IV)来执行 AES 加密。

开启 StrongIV 后，魔曰将使用熵为 128bits 的 16 字节初始化向量来执行 AES 加密。

开启本功能后，在多次使用相同密钥加密的情况下，出现密钥流重用的概率会大大降低。  
同时会将密文增长 16 字节，导致输出结果变长。

### HMAC-SHA256

魔曰默认不对消息进行强完整性验证，仅使用 [**卢恩算法**](https://zh.wikipedia.org/zh-cn/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95)(US2950048， ISO/IEC 7812-1) 来对解密结果做简单校验。

打开 HMAC 后，魔曰将对密文执行 SHA-256 哈希签名，并将签名附加在密文之后。

开启本功能可防止针对密文的恶意篡改，同时会将密文增长 32 字节，导致输出结果变长。

### PBKDF2

::: tip 提示

启用 PBKDF2 后，由于需要执行十万次密钥迭代，会导致加密/解密卡顿。

:::

魔曰默认直接使用密钥的一次 SHA-256 哈希作为加密密钥。

打开 PBKDF2 后，魔曰将会取 16 字节的随机盐值，对密钥执行 100000 次哈希迭代，用迭代后的密钥执行加密，并将盐值附加在加密数据之后。

开启本功能可防止针对密钥哈希的彩虹表攻击，同时会将密文增长 16 字节，导致输出结果变长。

### TOTP

::: tip 提示

TOTP 不是安全性的保证，它可以减少 PBKDF2 算法对密文长度的影响，但并不显著增加密钥熵。

用户必须先启用 KDF 才能启用 TOTP。

:::

TOTP 是 PBKDF2 的附加功能，允许用户向密文增加解密时效性。

魔曰使用经过简单修改的 TOTP 算法，使其最终输出 16 位数字而非传统的 6~8 位。并不直接将 TOTP 密钥用于加密，而是将其作为盐值参与 PBKDF2 的密钥派生。

允许用户自定义 TOTP 加密解密所使用的时间戳(默认为系统时间)，每步时间大小，和预共享密钥(默认为加密主密钥)。

## 三重转轮混淆

转轮混淆之前的原文，是一个使用 AES 加密后数据编码而成的 Base64 字符串，转轮混淆对其的处理为彻底打乱 Base64 字符串的字母/数字/符号，使其无法被正常解码为上一层 AES256 加密后的字节数据(包括两字节 IV 在内)。

```mermaid
graph LR
    A["Base64_Character"] --> B["RoundKeyMatch()"]
    B --> C["LETTERS_ROUND_1"]
    B --> D["LETTERS_ROUND_2"]
    B --> E["LETTERS_ROUND_3"]
    C --> F["Rotated_Character"]
    D --> F
    E --> F
    F --> G["getCryptText()"]
    G --> H["Chinese_Character"]

    I["RoundKey()"] --> J["Rotor_Rotation"]
    J --> C
    J --> D
    J --> E
```

### 密钥和操作数

1. 对密钥进行 SHA256
2. 对 SHA256 后得到的 32 字节数组中的每个元素执行对十取余，得到一个操作数数组(这个数组中每个元素的大小不超过 9，不小于 0)

### 轮转规则

混淆时，每混淆/映射一个字符，就取当前操作数，执行一次转轮轮转，并将当前操作数的索引偏移一位。

下次加密便会从操作数数组中取下一个操作数执行转轮轮转。如果取到数组末尾，则从头开始，循环往复。

轮转方向和距离由当前操作数(N)决定。  
遵守以下规则：

- 如果操作数为 0，将其当作 10 并继续

如果该操作数是偶数(N%2 == 0)

- 将第一个密钥轮向右轮 6 位
- 将第二个密钥轮向左轮 N\*2 位
- 将第三个密钥轮向右轮(N/2)+1 位

如果该操作数是奇数(N%2 != 0)

- 将第一个密钥轮向左轮 3 位
- 将第二个密钥轮向右轮 N 位
- 将第三个密钥轮向左轮(N+7)/2 位

其中，第一个和第三个转轮为顺序轮，第二个转轮为乱序(手动打乱)轮。

转轮每次转动方向和距离由操作数组(密钥)决定
可能的密钥空间为 10^32。

### 映射规则

映射采用 字母 -> 索引 -> 字母 -> 索引 的重复操作。

设立一个原映射标准字符串(实际比这个要长得多)

```
abcdefjhigk....
```

三个转轮的长度和原字符串一致。
假设三个转轮状态如下。
(下一个字符加密时会轮转)

```
bcdefjhigka....
edfbjichgak....
fjhigkabcde....
```

现在，假设我们要混淆字符 a

1. 在原字符串中找到字符 a 的索引，得到 0
2. 在第一个转轮中查找索引 0，得到字符 b
3. 在原字符串中查找字符 b 的索引，得到 1
4. 在第二个转轮中查找索引 1，得到字符 d
5. 在原字符串中查找字符 d 的索引，得到 3
6. 在第三个转轮中查找索引 3，得到字符 i

由此完成了 a --> i 的转轮映射。

其他所有字符以此类推，均可得到一个映射。  
(这个映射可以和原文本相同，修正了 Enigma 机的弱点)

每轮转一次转轮，都会得到一个完全不同的映射表，轮转规则见上一小节。

## 加密总流程

<br>

```mermaid
graph TD

    subgraph "加密"
        RANDBYTES["Random IV Generation"]
        AES256["AES-256-CTR/高级加密"]
        KEYDERIV["Key Derivation"]
    end

    subgraph "编码和混淆"
        BASE64["Base64.fromUint8Array()"]
        RMPADDING["RemovePadding()"]
        ROTORSYS["三重转轮混淆"]
    end

    RANDBYTES --> KEYDERIV
    KEYDERIV --> AES256
    AES256 --> BASE64
    BASE64 --> RMPADDING
    RMPADDING --> ROTORSYS
```
